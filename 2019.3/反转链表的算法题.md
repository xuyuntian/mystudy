# 反转链表2
## 题目：
* Reverse a linked list from position m to n. Do it in one-pass.
* note:1 ≤ m ≤ n ≤ length of list.
* **例子:**
<table><tr><td bgcolor=#999>
Input: 1->2->3->4->5->NULL, m = 2, n = 4<br>
Output: 1->4->3->2->5->NULL
</td></tr></table> 

## 个人代码
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode countPoint = head;
        int count = 0;
        //计算链表长度
        while(countPoint!=null){
            count++;
            countPoint = countPoint.next;
        }
        //链表长度不足2时直接返回head
        if(count<=1){
            return head;
        }
        //声明数组
        ListNode[] myArray = new ListNode[count];
        int index = 0;
        //遍历链表依次放入数组
        while(head!=null){
            myArray[index++] = head;
            head = head.next;
        }
        //当m与n不相等时进行反转(m<n)
        if(m!=n){
            m--;//将m与数组的索引对应
            n--;//将n与数组的索引对应
            //计算m到n之间的节点个数并/2
            int midle = (n-m+1)/2;
            //进行首尾交换达到反转目的
            for(int i =0;i<midle;i++){
                ListNode temp = myArray[m];
                myArray[m] = myArray[n];
                myArray[n] = temp;
                n--;
                m++;
            }
        }
        //重新连接节点
        for(int i = 0;i<myArray.length-1;i++){
            myArray[i].next = myArray[i+1];
        }
        myArray[myArray.length-1].next=null;
        //返回头部节点
        return myArray[0];
    }
}
```
## 思路
使用数组保存所有节点,然后将索引m-1到n-1之间的节点反转。<br>
然后重新连接链表,返回头节点。

## 自己犯的错误
1.交换数据的代码出错浪费了半个小时的时间排查错误<br>
2.最后的节点没有把他的next属性置为空,形成了环，在运行第五个用例的时候出现内存溢出错误。